"""
This type stub file was generated by pyright.
"""

import asyncio
import concurrent.futures
from types import TracebackType
from typing import (
    AsyncContextManager,
    Awaitable,
    Callable,
    ContextManager,
    Coroutine,
    Optional,
    Protocol,
    TypeVar,
)
from langchain_core.runnables import RunnableConfig
from typing_extensions import ParamSpec

P = ParamSpec("P")
T = TypeVar("T")

class Submit(Protocol[P, T]):
    def __call__(
        self,
        fn: Callable[P, T],
        *args: P.args,
        __name__: Optional[str] = ...,
        __cancel_on_exit__: bool = ...,
        __reraise_on_exit__: bool = ...,
        __next_tick__: bool = ...,
        **kwargs: P.kwargs,
    ) -> concurrent.futures.Future[T]: ...

class BackgroundExecutor(ContextManager):
    """A context manager that runs sync tasks in the background.
    Uses a thread pool executor to delegate tasks to separate threads.
    On exit,
    - cancels any (not yet started) tasks with `__cancel_on_exit__=True`
    - waits for all tasks to finish
    - re-raises the first exception from tasks with `__reraise_on_exit__=True`"""
    def __init__(self, config: RunnableConfig) -> None: ...
    def submit(
        self,
        fn: Callable[P, T],
        *args: P.args,
        __name__: Optional[str] = ...,
        __cancel_on_exit__: bool = ...,
        __reraise_on_exit__: bool = ...,
        __next_tick__: bool = ...,
        **kwargs: P.kwargs,
    ) -> concurrent.futures.Future[T]: ...
    def done(self, task: concurrent.futures.Future) -> None: ...
    def __enter__(self) -> Submit: ...
    def __exit__(
        self,
        exc_type: Optional[type[BaseException]],
        exc_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> Optional[bool]: ...

class AsyncBackgroundExecutor(AsyncContextManager):
    """A context manager that runs async tasks in the background.
    Uses the current event loop to delegate tasks to asyncio tasks.
    On exit,
    - cancels any tasks with `__cancel_on_exit__=True`
    - waits for all tasks to finish
    - re-raises the first exception from tasks with `__reraise_on_exit__=True`
      ignoring CancelledError"""
    def __init__(self, config: RunnableConfig) -> None: ...
    def submit(
        self,
        fn: Callable[P, Awaitable[T]],
        *args: P.args,
        __name__: Optional[str] = ...,
        __cancel_on_exit__: bool = ...,
        __reraise_on_exit__: bool = ...,
        __next_tick__: bool = ...,
        **kwargs: P.kwargs,
    ) -> asyncio.Task[T]: ...
    def done(self, task: asyncio.Task) -> None: ...
    async def __aenter__(self) -> Submit: ...
    async def __aexit__(
        self,
        exc_type: Optional[type[BaseException]],
        exc_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None: ...

async def gated(semaphore: asyncio.Semaphore, coro: Coroutine[None, None, T]) -> T:
    """A coroutine that waits for a semaphore before running another coroutine."""
    ...

def next_tick(fn: Callable[P, T], *args: P.args, **kwargs: P.kwargs) -> T:
    """A function that yields control to other threads before running another function."""
    ...

async def anext_tick(coro: Coroutine[None, None, T]) -> T:
    """A coroutine that yields control to event loop before running another coroutine."""
    ...
