"""
This type stub file was generated by pyright.
"""

from functools import cached_property
from typing import (
    Any,
    AsyncIterator,
    Callable,
    Iterator,
    Mapping,
    Optional,
    Sequence,
    Union,
)
from langchain_core.runnables import (
    Runnable,
    RunnableConfig,
    RunnablePassthrough,
    RunnableSerializable,
)
from langchain_core.runnables.base import Input, Other
from langchain_core.runnables.utils import ConfigurableFieldSpec
from langgraph.pregel.retry import RetryPolicy
from langgraph.utils.runnable import RunnableCallable

READ_TYPE = Callable[[Union[str, Sequence[str]], bool], Union[Any, dict[str, Any]]]

class ChannelRead(RunnableCallable):
    """Implements the logic for reading state from CONFIG_KEY_READ.
    Usable both as a runnable as well as a static method to call imperatively."""

    channel: Union[str, list[str]]
    fresh: bool = ...
    mapper: Optional[Callable[[Any], Any]] = ...
    @property
    def config_specs(self) -> list[ConfigurableFieldSpec]: ...
    def __init__(
        self,
        channel: Union[str, list[str]],
        *,
        fresh: bool = ...,
        mapper: Optional[Callable[[Any], Any]] = ...,
        tags: Optional[list[str]] = ...,
    ) -> None: ...
    def get_name(
        self, suffix: Optional[str] = ..., *, name: Optional[str] = ...
    ) -> str: ...
    @staticmethod
    def do_read(
        config: RunnableConfig,
        *,
        select: Union[str, list[str]],
        fresh: bool = ...,
        mapper: Optional[Callable[[Any], Any]] = ...,
    ) -> Any: ...

DEFAULT_BOUND: RunnablePassthrough = ...

class PregelNode(Runnable):
    """A node in a Pregel graph. This won't be invoked as a runnable by the graph
    itself, but instead acts as a container for the components necessary to make
    a PregelExecutableTask for a node."""

    channels: Union[list[str], Mapping[str, str]]
    triggers: list[str]
    mapper: Optional[Callable[[Any], Any]]
    writers: list[Runnable]
    bound: Runnable[Any, Any]
    retry_policy: Optional[RetryPolicy]
    tags: Optional[Sequence[str]]
    metadata: Optional[Mapping[str, Any]]
    def __init__(
        self,
        *,
        channels: Union[list[str], Mapping[str, str]],
        triggers: Sequence[str],
        mapper: Optional[Callable[[Any], Any]] = ...,
        writers: Optional[list[Runnable]] = ...,
        tags: Optional[list[str]] = ...,
        metadata: Optional[Mapping[str, Any]] = ...,
        bound: Optional[Runnable[Any, Any]] = ...,
        retry_policy: Optional[RetryPolicy] = ...,
    ) -> None: ...
    def copy(self, update: dict[str, Any]) -> PregelNode: ...
    @cached_property
    def flat_writers(self) -> list[Runnable]:
        """Get writers with optimizations applied. Dedupes consecutive ChannelWrites."""
        ...

    @cached_property
    def node(self) -> Optional[Runnable[Any, Any]]:
        """Get a runnable that combines `bound` and `writers`."""
        ...

    def join(self, channels: Sequence[str]) -> PregelNode: ...
    def __or__(
        self,
        other: Union[
            Runnable[Any, Other],
            Callable[[Any], Other],
            Mapping[str, Runnable[Any, Other] | Callable[[Any], Other]],
        ],
    ) -> PregelNode: ...
    def pipe(
        self,
        *others: Runnable[Any, Other] | Callable[[Any], Other],
        name: Optional[str] = ...,
    ) -> RunnableSerializable[Any, Other]: ...
    def __ror__(
        self,
        other: Union[
            Runnable[Other, Any],
            Callable[[Any], Other],
            Mapping[str, Union[Runnable[Other, Any], Callable[[Other], Any]]],
        ],
    ) -> RunnableSerializable: ...
    def invoke(
        self,
        input: Input,
        config: Optional[RunnableConfig] = ...,
        **kwargs: Optional[Any],
    ) -> Any: ...
    async def ainvoke(
        self,
        input: Input,
        config: Optional[RunnableConfig] = ...,
        **kwargs: Optional[Any],
    ) -> Any: ...
    def stream(
        self,
        input: Input,
        config: Optional[RunnableConfig] = ...,
        **kwargs: Optional[Any],
    ) -> Iterator[Any]: ...
    async def astream(
        self,
        input: Input,
        config: Optional[RunnableConfig] = ...,
        **kwargs: Optional[Any],
    ) -> AsyncIterator[Any]: ...
