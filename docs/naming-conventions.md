# Naming Conventions

## 1. Introduction

This document establishes clear and consistent naming conventions for key entities, Pydantic schemas, database models, classes, functions, and other significant components within the Systematic Review Assistant (SRA) project. Adherence to these conventions is crucial for improving code readability, maintainability, and fostering a shared understanding across the development team (including AI agents).

## 2. General Principles

-   **Clarity and Descriptiveness:** Prefer names that clearly describe the entity's or component's purpose over excessive brevity.
-   **Consistency:** Apply these conventions uniformly across the entire codebase and all related documentation.
-   **Standard Python Conventions:**
    -   **PascalCase (CapWords):** Used for class names (Pydantic models, SQLModels, Service classes, Repository classes, Enum classes).
    -   **snake_case:** Used for function names, method names, variable names, module/file names (e.g., `my_function`, `my_variable`, `services.py`). This aligns with PEP 8.
    -   **UPPER_SNAKE_CASE:** Used for constants and Enum members.

## 3. Terminology Clarification

To avoid ambiguity, the following terms will be used consistently:

-   **Model (or Database Model):** Refers specifically to **SQLModel** classes defined in `src/sr_assistant/core/models.py`. These classes map directly to database tables and define the structure of persistent data entities (e.g., `SystematicReview`, `SearchResult`).
-   **Schema (or Pydantic Schema):** Refers specifically to **Pydantic model** classes, typically defined in `src/sr_assistant/core/schemas.py`. These are used for:
    -   Data validation.
    -   Serialization and deserialization.
    -   Defining API contracts (Data Transfer Objects - DTOs) between the UI layer and the Service layer.
    -   Specifying the expected structure for inputs to and outputs from Large Language Model (LLM) chains.
    (e.g., `SystematicReviewCreate`, `SearchResultRead`, `ScreeningResponse`).

## 4. Pydantic Schema Naming Conventions

All Pydantic schemas inherit from `core.schemas.BaseSchema` (unless they are `typing.TypedDict`).

### 4.1. Schemas for Service Layer Data Transfer Objects (DTOs)

These schemas are used for data interchange with the service layer methods.

-   **Create Operations:** `[EntityName]Create`
    -   Purpose: Defines the data structure expected by a service method to create a new entity.
    -   Example: `SystematicReviewCreate`, `ScreeningResultCreate`.
-   **Read Operations:** `[EntityName]Read`
    -   Purpose: Defines the data structure returned by a service method when fetching entity data. Often includes read-only fields generated by the database (e.g., `id`, `created_at`, `updated_at`).
    -   Example: `SystematicReviewRead`, `SearchResultRead`.
-   **Update Operations:** `[EntityName]Update`
    -   Purpose: Defines the data structure expected by a service method to update an existing entity. All fields intended for update should be optional.
    -   Example: `SystematicReviewUpdate`, `SearchResultUpdate`.
-   **Delete Operations:** (Less common for dedicated schemas, often just an ID is passed)
    -   If a schema is needed: `[EntityName]Delete` or `[EntityName]DeleteCriteria`.

### 4.2. Schemas for Filtering/Querying Parameters

-   **Filter/Query Schemas:** `[EntityName]Filter` or `[EntityName]QueryCriteria`
    -   Purpose: Defines the set of parameters that can be used to filter or query a collection of entities.
    -   Example: `SearchResultFilter` (for filtering search results), `SystematicReviewFilter`.
    -   Fields should correspond to queryable attributes of the entity.

### 4.3. Schemas for LLM Input/Output

-   Named descriptively based on their specific purpose in the LLM interaction. Generally, for schemas representing the direct, raw structured output from an LLM, the suffix `Response` (e.g., `[Action]Response`) is preferred for consistency.
-   If an LLM output directly leads to the creation of a database model or a service DTO, its schema might share a root name but have a distinct suffix or prefix if its structure or purpose is different before further processing.
-   Examples:
    -   `ScreeningResponse`: Raw structured output from individual screening LLM reviewers. (Adheres to `[Action]Response`)
    -   `ResolverOutputSchema`: Raw structured output from the resolver LLM.
    -   `ScreeningResolutionCreate`, `ScreeningResolutionRead`: For service layer interaction with `ScreeningResolution` entities.
    -   `PicosSuggestions`: Structured PICO suggestions from an LLM. (Specific descriptive name, acceptable as it's not a generic "response" to an action but a specific data structure delivered by the suggestion agent).
    -   `ScreenAbstractsChainInput`: Input variables for the abstract screening chain prompt. (Clearly an input schema).

### 4.4. Internal/Helper Schemas

-   Named descriptively based on their content and specific purpose.
-   Example: `ExclusionReasons` (a nested schema within `ScreeningResponse`).

## 5. Database Model Naming Conventions (SQLModel)

-   **Class Name:** PascalCase, singular form, representing the entity.
    -   Example: `SystematicReview`, `SearchResult`, `ScreenAbstractResult`, `ScreeningResolution`, `LogRecord`.
-   **Table Name (`__tablename__`):** snake_case, plural form.
    -   Example: `systematic_reviews`, `search_results`, `screen_abstract_results`, `screening_resolutions`, `log_records`.

## 6. Service Class Naming

-   `[EntityName]Service` (if primarily focused on one entity) or a name describing the domain of operations.
-   Example: `SearchService`, `ReviewService`, `ScreeningService`.

## 7. Repository Class Naming

-   `[EntityName]Repository`
-   Example: `SearchResultRepository`, `SystematicReviewRepository`, `ScreeningResolutionRepository`.

## 8. File Naming

-   **Python Modules (`.py`):** `snake_case.py`.
    -   Examples: `services.py`, `models.py`, `schemas.py`, `screening_agents.py`.
    -   If a module contains schemas for a specific entity and grows large, consider `[entity_name]_schemas.py` (e.g., `search_result_schemas.py`).
-   **Markdown Documents (`.md`):** `kebab-case.md` or `snake_case.md`. Project should choose one and be consistent within `docs/`.
    -   Current preference in `docs/` seems to be `kebab-case.md` (e.g., `api-reference.md`, `data-models.md`).

## 9. Variable and Function/Method Naming

-   Adhere to PEP 8 `snake_case`.
-   Examples: `get_all_reviews`, `search_result_id`, `screening_data`.

## 10. Enum Naming

-   **Enum Class:** PascalCase.
    -   Example: `ScreeningDecisionType`, `CriteriaFramework`.
-   **Enum Members:** UPPER_SNAKE_CASE.
    -   Example: `ScreeningDecisionType.INCLUDE`, `CriteriaFramework.PICO`.

## 11. Document Maintenance

This document should be reviewed and updated if new categories of components or entities requiring naming conventions are introduced, or if existing conventions need refinement.

## Change Log

| Change          | Date       | Version | Description             | Author          |
|-----------------|------------|---------|-------------------------|-----------------|
| Initial Draft   | 2025-05-12 | 0.1     | First draft of Naming Conventions document. | Architect Agent |
| LLM Schema Clarification | 2025-05-12 | 0.2     | Clarified preferred naming for LLM output schemas and noted `ScreeningResolutionSchema` as a deviation for future refactoring. | Architect Agent |
| Schema Rename | 2025-05-15 | 0.3     | Renamed `ScreeningResolutionSchema` to `ResolverOutputSchema` globally. | AI Assistant | 